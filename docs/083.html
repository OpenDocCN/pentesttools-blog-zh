<html>
<head>
<title>Authenticated Magento RCE with deserialized PHAR files | Pentest-Tools.com</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>通过反序列化的 PHAR 文件认证的 Pentest-Tools.com RCE</h1>
<blockquote>原文：<a href="https://pentest-tools.com/blog/magento-authenticated-rce#2022-07-26T17:15:14.000Z">https://pentest-tools.com/blog/magento-authenticated-rce#2022-07-26T17:15:14.000Z</a></blockquote><div><div class="prose prose-headings:break-words prose-img:rounded-md prose-img:ring-1 prose-img:ring-dark-blue-200 prose-img:ring-opacity-30 prose-code:break-words prose-headings:[scroll-margin-top:120px] xl:prose-lg xl:prose-headings:w-[628px] xl:prose-p:w-[628px]">
            
              
                
                  <p>回到 2019 年 8 月，我使用<a target="_blank" rel="external nofollow noopener noreferrer" href="https://hackerone.com/magento"> HackerOne bug bounty 平台</a>报告了 Magento 中影响 2.3.2、2.3.3 和 2.3.4 版本的安全漏洞。</p><p>该错误影响了 Magento 的一些安装，并允许我们基于 PHAR 文件的反序列化方式和滥用 Magento 的协议指令来获得远程代码执行。</p><p>Adobe 于 2020 年 4 月 28 日修补了该漏洞。在撰写本文时，漏洞报告尚未公开。</p><p>鉴于此漏洞可被任何权限级别的用户利用，它对未打补丁的部署有很高的业务风险影响。</p><h2 id="1-vulnerability-analysis">1.弱点分析</h2><p>来深究一下细节吧！下面我们将回顾受影响的 Magento 版本和实例，导致漏洞的原因，以及如何利用它来实现远程代码执行。</p><h3 id="tldr">TL；速度三角形定位法(dead reckoning)</h3><p>为了更好地执行后续步骤，这里总结了攻击顺序:</p><p>1.并非所有 Magento 2.3.2、2.3.3 和 2.3.4 实例都会受到影响。从 2.3.1 开始，默认情况下禁用 PHAR 支持。在默认的 Magento 安装中，你可以在<strong> app/bootstrap.php </strong>下检查 PHAR 支持是否被禁用。如果你找到下面的代码片段，你的 Magento 安装是<strong>而不是</strong>受影响的:</p><div class="content-highlight"><pre class="code-block"><code>if (in_array('phar', \stream_get_wrappers())) {
    stream_wrapper_unregister('phar');
}</code></pre></div><p>2.该漏洞存在于管理界面中，您可以通过向页面添加新图像来触发它。PHAR 档案可以嵌入到 JPEGs 文件中——继续阅读了解如何嵌入。该图像将被传递给一个<strong> getimagesize() </strong>，如果文件名以<strong>“phar://”</strong>开头，它将触发<a href="https://pentest-tools.com/blog/exploit-phar-deserialization-vulnerability">反序列化</a></p><p>3.在这种情况下，它不会，我们需要找到一种方法来绕过这一点。在前端，图像 src 被设置为{{media url= <strong> filename </strong> }}。这将决定 Magento 的<strong>媒体指令</strong>要处理的图像。我们发现的错误允许我们改变 src 来访问<em>另一个</em>指令。所以我们使用了<strong>协议指令</strong>，它允许我们完全控制文件名。</p><p>4.剩下的唯一事情就是找到可以在 POP 链中使用的类来实现 RCE。我们使用了<strong>guzzle http/Stream/FnStream</strong>和<strong> phpseclib\Crypt\Hash </strong>。</p><h3 id="background-embedding-phar-in-jpegs">背景:在 JPEGs 中嵌入 PHAR</h3><p>这种攻击需要能够在服务器上放置 PHAR 档案，因为只有当包装器引用的资源是本地资源时，才会考虑包装器。</p><p>您可能知道，文件上传受到各种限制。当试图利用这种漏洞时，能够创建既作为 PHAR 存档有效又作为另一种文件类型(如 JPEG)有效的文件是很有用的。</p><p>您可以用三种文件格式存储 PHARs:phar、tar 和 zip。对于这个例子，让我们研究一下 TAR 格式，因为它提供了一些您可以使用的灵活性。</p><p>让我们使用 phar、tar 和 jpeg 的以下属性来创建有效的 TAR/JPEG 多语种文件:</p><ul><li><p><strong> jpeg </strong>:可以在元数据中插入任意长度的注释</p></li><li><p><strong> tar </strong>:档案的前 100 个字节包含档案的第一个文件名；存档的结尾由 1024 个连续的 0 字节标记</p></li><li><p><strong> phar </strong>:任何数量的数据都可以放在存根的开头。</p></li></ul><p>然后，您可以在 JPEG 文件中嵌入 PHAR 档案:</p><ol start="1"><li><p>以 JPEG 开始标记<strong> 0xFFD8 </strong>开始归档，后面是注释开始<strong> 0xFFFE </strong>和注释长度。</p></li><li><p>然后跟随实际的注释，这将是我们的 phar 存档，加上 1024 个零来标记存档结束。因此，注释的长度等于存档内容的长度+ 1024。</p></li><li><p>之后是图像数据。</p></li></ol><p>一个假设的 JPG/PHAR 多语言者将具有以下结构:</p><p><strong>0x ffd 8 |</strong><strong>0x fffe</strong>|<strong>评论 _ 长度|</strong>|<strong>PHAR _ 数据</strong> | <strong>存档 _ 结束</strong> | <strong>图像 _ 数据</strong></p><h3 id="practical-analysis">实用分析</h3><p>该漏洞存在于 Magento 的 WYSIWYG 编辑器中负责渲染图像的组件中。</p><p>编辑器有两种状态，<strong>显示</strong>和<strong>隐藏</strong>。每当您从<strong>隐藏</strong>切换到<strong>显示</strong>时，页面上的每个图像都会向一个端点发出 GET 请求。看起来是这样的:</p><p>magento.url/admin/cms/wysiwyg/directive/___directive/<strong>base64(图片。src) </strong> /...</p><p>在后端，这到达<strong>供应商/magento/模块-CMS/控制器/ </strong></p><p><strong> Adminhtml/WYSIWYG/directive。PHP </strong></p><div class="content-highlight"><pre class="code-block"><code>public function execute()

{

      $directive = $this-&gt;getRequest()-&gt;getParam('___directive');

      $directive = $this-&gt;urlDecoder-&gt;decode($directive);

[...snip...]

try   {

                      $filter = $this-&gt;_objectManager-&gt;create(Filter::class);

                      $imagePath = $filter-&gt;filter($directive);

                      $image = …

                       [...snip...]

                       $image-&gt;open($imagePath);

                       [...snip...]

      }

}</code></pre></div><p>前面提到的 base64 编码图像 src 被看作是<strong> $directive </strong>变量的值。</p><p>默认情况下，该 src 的格式为<strong>{ { media URL = image-name } }</strong>。在这里，<strong>媒体</strong>就是我们所说的<strong>指令</strong>。</p><p>这很重要，因为<strong>Directive.php</strong>中的下一步是对<strong>_ _ 指令</strong>:<strong>$ image path = $ filter-&gt;filter($ directive)应用一些过滤；</strong></p><p>该滤波的结果将是<strong>一个图像路径</strong>，其值取决于 src 中使用的指令。我们一会儿将回到这一点。</p><p>获得图像路径后，创建一个新的图像对象。同时，图像被打开。处理打开的函数调用<strong> getimagesize(imagePath) </strong>，该函数将<a href="https://pentest-tools.com/blog/exploit-phar-deserialization-vulnerability"> <strong>反序列化 PHAR 档案</strong> </a>。</p><p>让我们通过一个例子来看看这是如何发生的:</p><ol start="1"><li><p>上传一个名为 phar.jpg 的新图片到我们的 Magento 网页。</p></li><li><p>添加图像为:<code>&lt;img src="{{media url=”phar.jpg”}}" alt="" &gt;</code></p></li><li><p>按按钮显示所见即所得编辑器。在后端，<strong>Directive.php</strong>会收到<strong> {{media url="phar.jpg"}} </strong>。</p></li><li><p>这将被传递给过滤函数，产生<strong>图像路径</strong>。</p></li><li><p>使用在调用<strong>$ image-&gt;open($ image path)</strong>中得到的图像路径；在这种情况下，<strong> $imagePath </strong>将是<strong> pub/media/phar.jpg </strong>，其中<strong> pub/media </strong>是 Magento 中的默认媒体位置。</p></li></ol><p>为了反序列化 PHAR，您需要控制传递给<strong> getimagesize() </strong>的名称的开头。正如我们关于 PHAR 反序列化的技术指南中所述，只有当文件名看起来像“<strong> phar://… </strong>”时，反序列化才有效。</p><p>所以你需要找到一种方法来完全控制产生的<strong>图像路径</strong>。</p><h3 id="protocol-directive">协议指令</h3><p>回到<strong>Directive.php</strong>，我们知道图像路径是调用<strong>$ image path = $ filter-&gt;filter($ directive)</strong>的结果。</p><p>$filter 对象是 Magento \ \ Cms \ \ Model \ \ Template \ \ Filter 类的一个实例，它继承了 Magento \ \ Email \ \ Model \ \ Template \ \ Filter 类。保留这些细节，因为它们以后会有用。</p><p>filter 方法将尝试将<strong>$指令</strong>匹配到一个特定的正则表达式。基于匹配，它将对基于<strong> $directive </strong>中的指令的方法进行回调。</p><p>在默认场景中，使用<strong>{ { media URL = " phar . jpg " } }</strong>作为输入，将调用<strong> mediaDirective </strong>。这个方法属于<strong>Magento \ \ Cms \ \ Model \ \ Template \ \ Filter</strong>。如前所述，这个类继承了<strong>Magento \ \ Email \ \ Model \ \ Template \ \ Filter</strong>，幸运的是它包含了更多的指令方法。</p><p>这意味着您可以更改输入来访问另一个指令。对于这个深入研究，我们使用了<strong> protocolDirective </strong>，您可以使用它来控制图像的最终名称。要访问该指令，您必须提供以下格式的输入<strong>{ {协议...}} </strong></p><p>让我们看一下这个方法的代码片段:</p><div class="content-highlight"><pre class="code-block"><code>public function protocolDirective($construction)

{

        $params = $this-&gt;getParameters($construction[2]);

        $isSecure = 



$this-&gt;_storeManager-&gt;getStore($store)-&gt;isCurrentlySecure();

      $protocol = $isSecure ? 'https' : 'http';

      if  (isset($params['url']))   {

               return $protocol . '://' . $params['url'];

      } elseif (isset($params['http']) &amp;&amp; isset($params['https'])) {

            if ($isSecure)    {

                return $params['https'];

            }

             return $params['http'];

      }

      return $protocol;

}</code></pre></div><p>从第一行开始，<strong> $params </strong>将是一个关联数组。如果你看下面，你可以看到它包括 3 个相关的键:<strong> url </strong>、<strong> http </strong>和<strong> https </strong>。</p><p>如果未设置<strong>$ params[' URL ']</strong><strong>并且设置了<strong> $params['http'] </strong>和<strong> $params['https'] </strong>，则该方法将根据商店是否使用 https 返回作为<strong> http </strong>或<strong> https </strong>的值传递的任何内容。</strong></p><p>那么您得到的有效负载是:<strong>{ { protocol http = " phar://phar . jpg " https = " phar://phar . jpg " } }</strong>。</p><p>用这个作为前端图片的<strong> src </strong>会导致<strong>$ image path = " phar://phar . jpg "</strong>触发反序列化。</p><h3 id="profit">利润</h3><p>我们现在需要一个 POP 链来包含在我们的 PHAR 中，以利用该应用程序。</p><p>使用的类是<strong>guzzle http/Stream/FnStream</strong>和<strong> phpseclib\Crypt\Hash </strong>。</p><p><strong>guzzle http/Stream/FnStream</strong>的析构函数用于启动漏洞链:</p><div class="content-highlight"><pre class="code-block"><code>public function __destruct()

{

      if (isset($this-&gt;_fn_close)) {

          call_user_func($this-&gt;_fn_close);

      }

}</code></pre></div><p>您可以使用它来回调当前作用域中任何类的任何方法。这方面的一个候选方法是再次使用 call_ <strong> user_func() </strong>，但是带有多个参数。这允许您使用像<strong> passthru() </strong>或<strong> exec() </strong>这样的函数在服务器上执行命令。</p><p><strong> phpseclib\Crypt\Hash </strong>的方法<strong> _computeKey </strong>进行这样的调用:</p><div class="content-highlight"><pre class="code-block"><code>function _computeKey()

{

          if ($this-&gt;key === false) {

               $this-&gt;computedKey = false;

               return;

      }

           if (strlen($this-&gt;key) &lt;= $this-&gt;b) {

$this-&gt;computedKey = $this-&gt;key;

                return;

      }

           switch ($this-&gt;engine) {

              //modified the cases to ease understanding

              case 2:

                     $this-&gt;computedKey = mhash($this-&gt;hash, $this-&gt;key);

                     break;

             case 3:

                     $this-&gt;computedKey = hash($this-&gt;hash, $this-&gt;key, true);

                     break;

             case 1:

                     $this-&gt;computedKey = call_user_func($this-&gt;hash, $this-&gt;key);

      }

}</code></pre></div><p>要使用该函数执行代码，您必须满足三个条件:</p><ol start="1"><li><p>将<strong>$键</strong>设置为比<strong> $b </strong>长的值。假设<strong> $key </strong>将是我们的服务器命令，您可以将$b 设置为一个小数字，比如 0</p></li><li><p>将<strong> $engine </strong>设置为 1，这样开关将转到最后一种情况。</p></li><li><p>将<strong> $hash </strong>设置为类似于<strong>“passthru”</strong>的值。</p></li></ol><h2 id="2-impact">2.影响</h2><p>通过滥用 Magento 的协议指令，任何经过验证的用户都可以上传精心制作的图像文件，该文件能够在 web 服务器用户的上下文中执行远程代码执行。</p><h2 id="3-proof-of-concept">3.概念证明</h2>

                

                
              
                
                  <div x-data="{ showVideo: false }" x-on:close.window.stop="showVideo = false" class="not-prose group relative flex items-center justify-center overflow-hidden rounded-xl">
  
  <p aria-hidden="true" class="pointer-events-none absolute inset-0 rounded-xl bg-gray-800 opacity-40"/>
  <p aria-hidden="true" class="absolute h-28 w-28 overflow-hidden rounded-full bg-white bg-opacity-5 shadow-lg ring-1 ring-white ring-opacity-20 transition duration-300 supports-backdrop-filter:backdrop-blur-sm group-hover:scale-110 group-hover:bg-opacity-10 group-hover:ring-opacity-30 sm:h-32 sm:w-32 lg:h-36 lg:w-36"/>
  <button type="button" aria-haspopup="true" x-bind:aria-expanded="showVideo ? showVideo : undefined" class="group absolute inset-0 flex w-full items-center justify-center rounded-3xl focus:outline-none" x-on:click="showVideo = true">
    <span class="sr-only">Play video</span>
    <svg class="h-24 w-24 rounded-full ring-offset-4 ring-offset-transparent transition-[box-shadow,transform] duration-300 group-hover:scale-105 group-focus:ring-4 group-focus:ring-white group-focus:ring-opacity-30 sm:h-28 sm:w-28 lg:h-32 lg:w-32" aria-hidden="true" viewbox="0 0 24 24" fill="none">
      <path class="text-white transition-[text-opacity] duration-300" fill="currentColor" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
      <path class="text-secondary-accent-500" fill="currentColor" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/>
    </svg>
  </button>

  
  

  <template x-if="showVideo">
    
















<template x-teleport="body">
  <div x-data="modal" class="fixed inset-0 z-120 overflow-hidden overflow-y-auto" x-on:keydown.escape.window.prevent.stop="close" x-on:close.window="close" x-show="open">
    <div class="flex h-full justify-center items-center px-4 pt-4 pb-16 sm:p-0">
      <p x-show="open" x-transition.opacity="" aria-hidden="true" class="fixed inset-0 bg-gray-500/75 transition-opacity" x-on:click.stop="close"/>

      
      

      <div x-show="open" x-transition:enter="duration-300 ease-out" x-transition:enter-start="translate-y-4 opacity-0 sm:translate-y-0 sm:scale-95" x-transition:enter-end="translate-y-0 opacity-100 sm:scale-100" x-transition:leave="duration-200 ease-in" x-transition:leave-start="translate-y-0 opacity-100 sm:scale-100" x-transition:leave-end="translate-y-4 opacity-0 sm:translate-y-0 sm:scale-95" role="dialog" aria-modal="true" aria-labelledby="modal-headline" class="transform transition-[opacity,transform] sm:my-8 h-auto sm:w-auto" x-trap.noscroll.inert="open" x-on:transitionend.self.debounce="$focus.first()">
        <div class="relative sm:w-screen sm:max-w-xl lg:max-w-3xl xl:max-w-5xl">
        <h2 id="modal-title" class="sr-only">如何实现认证的 Pentest-Tools.com RCE 使用反序列化 PHAR 文件</h2>
        
        <p class="aspect-video overflow-hidden rounded-lg">                    </p>
      </div>
      </div>
    </div>
  </div>
</template>


  


  </template>
</div>



                

                
              
                
                  <p/><p>负责任披露时间表</p><ul><li><p><strong>2019 年 8 月 29 日</strong> -提交给 HackerOne 的漏洞</p></li><li><p><strong>2019 年 9 月 12 日</strong>——黑客龙(HackerOne)排查出的 Bug</p></li><li><p><strong>2019 年 10 月 8 日</strong> - Magento (Adobe)安全团队回应</p></li><li><p><strong>2019 年 11 月 27 日</strong>-hacker one 颁发的赏金</p></li><li><p>2020 年 4 月 28 日-Adobe 发布的修复程序</p></li></ul>

                

                
              
            
          </div>
        </div>    
</body>
</html>